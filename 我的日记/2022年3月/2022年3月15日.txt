1、学习总结：
replace：取出堆中最大元素，并添加一个元素；原理：先把堆中最大元素(根节点)备份，将其(根节点)替换为要输入的元素，再对其进行siftDown
之后我们再把备份的原最大元素返回即可。我们可以用两种方式将一个数组整理成一个堆，第一种方式是将数组中所有元素进行siftDown排序，
这种方法的时间复杂度是O(nlogn)级别的，而另一种方法heapify：将任意一个数组整理成堆的形状；通过将数组中的元素从后到前，逐一进行
siftUp操作，即与其父节点比较，若比父节点大则交换，这种方法的时间复杂度为O(n)级。在使用过程中可以明显地感知到比前者方法效率高。
优先队列的底层可以使用最大堆来实现；入队操作即在堆中末尾添加元素并进行siftUp，出队操作即在堆中进行extractMax操作，即交换堆顶和
堆末尾元素，并删除末尾元素，并对堆顶元素进行siftDown操作。

2、今天本来时间比较宽裕的，但是导师把我们叫去开会了，还来了好几个已经参加工作的学长和我们分享经验，我又不学安全方向，实在是听不
懂，就这还开了两个多小时，有道题做了一半没做完，不过今天没时间了，明天再说吧。

3、明天计划：学习LeetCode上的优先队列相关问题和java中的PriorityQueue，锻炼计划：慢跑4公里。